//
// Copyright (c) 2017 SongCF <songcf_faith@foxmail.com>.
// https://github.com/golang/protobuf
//


package main

import (
	"container/list"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"bufio"
	"io"
	"strconv"
	"sort"
	"os/exec"
)

const (
	SUFFIX = ".proto"
	CMD_FIX = "// cmd:"
	MSG_FIX = "message "
	DESCRIBE_FIX = "// "
	FILE_NAME = "msgcode"
)

type Msg struct {
	cmd string
	name string
	desc string
}

// ./proto4go -i IN_DIR -o OUT_DIR
// ./proto4go -i . -o ./proto
func main() {
	argNum := len(os.Args)
	if argNum != 5 {
		fmt.Printf("Error args num: %v \nRight is: ./proto4go -i IN_DIR -o OUT_DIR", argNum)
		return
	}

	if !strings.EqualFold(os.Args[1], "-i") || !strings.EqualFold(os.Args[3], "-o") {
		fmt.Print("Error args format. \nRight is: ./proto4go -i IN_DIR -o OUT_DIR\n")
		return
	}

	inDir := os.Args[2]
	outDir := os.Args[4]

	protoFileL, err := WalkDir(inDir, SUFFIX)
	if err != nil {
		fmt.Println("Error: walk dir failed!")
		return
	}

	parse(protoFileL, outDir)

	fmt.Println("Success!")
}

func parse(fileL *list.List, outDir string) {
	cmdMap := make(map[int]*Msg)
	for e := fileL.Front(); e != nil; e = e.Next() {
		// do something with e.Value
		fmt.Printf("parse file: %v\n", e.Value)
		parseFile(e.Value.(string), &cmdMap, outDir)
	}
	keys := make([]int, 0)
	for k := range cmdMap {
		keys = append(keys, k)
		//fmt.Println("id:", k, ", name:", cmdMap[k].name, ", desc:", cmdMap[k].desc)
	}
	sort.Ints(keys)

	writeCodeFile(keys, &cmdMap, outDir)
	writeCSV(keys, &cmdMap, outDir)
}

func parseFile(fileName string, cmdMap *map[int]*Msg, outDir string) {
	f, err := os.Open(fileName)
	defer f.Close()
	if err != nil {
		fmt.Print("Error: parse error!")
		panic(err)
	}

	// gen *.pb.go
	command := exec.Command("protoc", "--go_out="+outDir, fileName)
	err = command.Run()
	check(err)

	buf := bufio.NewReader(f)
	lastLine := ""
	tmpLine := lastLine
	for {
		tmpLine = lastLine
		// line
		line, err := buf.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Print("Error: read line error!")
			panic(err)
		}

		//parse cmd
		idx := strings.Index(line, CMD_FIX)
		if idx < 0 {
			lastLine = line
			continue
		}
		cmd := line[idx+len(CMD_FIX):len(line)-1]
		id, err := strconv.Atoi(cmd)
		if err != nil{
			fmt.Println("Error format!")
			panic(err)
		}
		//parse message
		line, err = buf.ReadString('\n')
		if err != nil{
			fmt.Println("Error format!")
			panic(err)
		}
		idx = strings.Index(line, MSG_FIX)
		if idx < 0 {
			fmt.Println("Error format!")
			panic(line)
		}
		idx2 := strings.Index(line, " {")
		msg := "\"" + line[idx+len(MSG_FIX):idx2] + "\""
		//parse describe
		idx = strings.Index(tmpLine, DESCRIBE_FIX)
		des := ""
		if idx >= 0 {
			des = tmpLine[idx+len(DESCRIBE_FIX):len(tmpLine)-1]
		}

		if _, ok := (*cmdMap)[id]; ok {
			fmt.Println("Error: duplicate cmd!")
			panic("Error: duplicate cmd!")
		}
		(*cmdMap)[id] = &Msg{
			cmd: cmd,
			name: msg,
			desc: des,
		}

		lastLine = line
	}
}

// walk dir and sub-dir, get all files with suffix
func WalkDir(dirPth, suffix string) (*list.List, error) {
	files := list.New()
	suffix = strings.ToUpper(suffix)                                                      //ignore
	err := filepath.Walk(dirPth, func(filename string, fi os.FileInfo, err error) error { //遍历目录
		if fi.IsDir() {
			return nil
		}
		if strings.HasSuffix(strings.ToUpper(fi.Name()), suffix) {
			files.PushBack(filename)
		}
		return nil
	})
	return files, err
}

// walk dir without sub-dir, get all files with suffix
func ListDir(dirPth string, suffix string) (*list.List, error) {
	files := list.New()
	dir, err := ioutil.ReadDir(dirPth)
	if err != nil {
		return nil, err
	}
	PthSep := string(os.PathSeparator)
	suffix = strings.ToUpper(suffix) //ignore
	for _, fi := range dir {
		if fi.IsDir() { // ignore sub-dir
			continue
		}
		if strings.HasSuffix(strings.ToUpper(fi.Name()), suffix) { //匹配文件
			files.PushBack(dirPth + PthSep + fi.Name())
		}
	}
	return files, nil
}


func writeCodeFile(keys []int, m *map[int]*Msg, dir string) {
	fileName := dir + "/" + FILE_NAME +".go"
	fmt.Printf("write map file: %v\n", fileName)

	f, err := os.OpenFile(fileName, os.O_WRONLY | os.O_CREATE, 0666)
	defer f.Close()
	if err != nil {
		fmt.Println("Error: open write file failed!")
		panic(err)
	}

	head := ""
	code := ""
	rcode := ""

	head += "//\n"
	head += "// Copyright (c) 2017 SongCF <songcf_faith@foxmail.com>.\n"
	head += "// file generated by proto4go\n"
	head += "// https://github.com/golang/protobuf\n"
	head += "//\n\n"
	head += "package pb\n\n\n"
	_, e := f.WriteString(head)
	check(e)

	//var Code = map[string]int{
	//	"heart_beat_req":         0,    // 心跳包
	//	"user_login_succeed_ack": 11,   // 登陆成功
	//	"client_error_ack":       13,   // 客户端错误
	//}
	//var RCode = map[int]string{
	//	10:   "user_login_req",         // 登陆
	//	11:   "user_login_succeed_ack", // 登陆成功
	//	1002: "proto_ping_ack",         // ping回复
	//}
	//var Handlers map[int]func(*Session, *packet.Packet) []byte
	code += "var Code = map[string]int{\n"
	rcode += "var RCode = map[int]string{\n"

	tmpStr := ""
	for _, k := range keys {
		tmpStr = fmt.Sprintf("\t%-24s:%-8s,  // %s\n", (*m)[k].name, (*m)[k].cmd, (*m)[k].desc)
		code += tmpStr
		tmpStr = fmt.Sprintf("\t%-8s:%-24s,  // %s\n", (*m)[k].cmd, (*m)[k].name, (*m)[k].desc)
		rcode += tmpStr
	}

	code += "}\n\n"
	rcode += "}\n\n"
	_, e = f.WriteString(code)
	check(e)
	_, e = f.WriteString(rcode)
	check(e)

	cmd := exec.Command("gofmt", "-w", fileName)
	e = cmd.Run()
	check(e)
}

func writeCSV(keys []int, m *map[int]*Msg, dir string) {
	fileName := dir + "/" + FILE_NAME +".csv"
	fmt.Printf("write csv file: %v\n", fileName)

	f, err := os.OpenFile(fileName, os.O_WRONLY | os.O_CREATE, 0666)
	defer f.Close()
	if err != nil {
		fmt.Println("Error: open write file failed!")
		panic(err)
	}

	_, e := f.WriteString("id,name,desc,\n")
	check(e)
	for _, k := range keys {
		_, e = f.WriteString((*m)[k].cmd + "," + (*m)[k].name + "," + (*m)[k].desc + ",\n")
		check(e)
	}
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}