//
// Copyright (c) 2017 SongCF <songcf_faith@foxmail.com>.
// https://github.com/golang/protobuf
//

package main

import (
	"bufio"
	"container/list"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

const (
	SUFFIX    = ".proto"
	CMD_FLAG  = "// cmd:"
	MSG_FLAG  = "message "
	DESC_FLAG = "// "
	FILE_NAME = "msgcode"
)

type Msg struct {
	cmd  string
	name string
	desc string
}

// ./proto4go -i IN_DIR -o OUT_DIR
// ./proto4go -i . -o ./proto
func main() {
	argNum := len(os.Args)
	if argNum != 5 {
		fmt.Printf("Error args num: %v \nRight is: ./proto4go -i IN_DIR -o OUT_DIR", argNum)
		return
	}

	if !strings.EqualFold(os.Args[1], "-i") || !strings.EqualFold(os.Args[3], "-o") {
		fmt.Print("Error args format. \nRight is: ./proto4go -i IN_DIR -o OUT_DIR\n")
		return
	}

	inDir := os.Args[2]
	outDir, err := filepath.Abs(os.Args[4])
	check(err)
	outDir = strings.Replace(outDir, "\\", "/", -1)
	//fmt.Println("out dir1: ", os.Args[4])
	fmt.Println("out dir2: ", outDir)

	protoFileL, err := WalkDir(inDir, SUFFIX)
	if err != nil {
		fmt.Println("Error: walk dir failed!")
		return
	}

	parse(protoFileL, outDir)

	fmt.Println("Success!")
}

func parse(fileL *list.List, outDir string) {
	cmdMap := make(map[int]*Msg)
	for elem := fileL.Front(); elem != nil; elem = elem.Next() {
		// do something with elem.Value
		fileName := elem.Value.(string)
		fmt.Printf("parse file: %v\n", fileName)
		// gen *.pb.go
		workDir := filepath.Dir(fileName)
		curDir := getCurrentDirectory()
		err := os.Chdir(workDir)
		check(err)
		base := filepath.Base(fileName)
		command := exec.Command("protoc", "--go_out="+outDir, base)
		//fmt.Printf("command: %v\n", command)
		err = command.Run()
		check(err)
		err = os.Chdir(curDir)
		check(err)
		// parse file
		parseFile(fileName, &cmdMap)
	}
	keys := make([]int, 0)
	for k := range cmdMap {
		keys = append(keys, k)
		//fmt.Println("id:", k, ", name:", cmdMap[k].name, ", desc:", cmdMap[k].desc)
	}
	sort.Ints(keys)

	writeCodeFile(keys, &cmdMap, outDir)
	writeCSV(keys, &cmdMap, outDir)
}

func parseFile(fileName string, cmdMap *map[int]*Msg) {
	f, err := os.Open(fileName)
	defer f.Close()
	if err != nil {
		fmt.Print("Error: parse error!")
		panic(err)
	}

	buf := bufio.NewReader(f)
	lastLine := ""
	tmpLine := lastLine
	for {
		tmpLine = lastLine
		// line
		line, err := buf.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Print("Error: read line error!")
			panic(err)
		}

		//parse cmd
		idx := strings.Index(line, CMD_FLAG)
		if idx < 0 {
			lastLine = line
			continue
		}
		cmd := line[idx+len(CMD_FLAG) : len(line)-1]
		id, err := strconv.Atoi(cmd)
		if err != nil {
			fmt.Println("Error format!")
			panic(err)
		}
		//parse message
		line, err = buf.ReadString('\n')
		if err != nil {
			fmt.Println("Error format!")
			panic(err)
		}
		idx = strings.Index(line, MSG_FLAG)
		if idx < 0 {
			fmt.Println("Error format!")
			panic(line)
		}
		idx2 := strings.Index(line, " {")
		msg := "\"" + line[idx+len(MSG_FLAG):idx2] + "\""
		//parse describe
		idx = strings.Index(tmpLine, DESC_FLAG)
		des := ""
		if idx >= 0 {
			des = tmpLine[idx+len(DESC_FLAG) : len(tmpLine)-1]
		}

		// check duplicate
		if _, ok := (*cmdMap)[id]; ok {
			fmt.Println("Error: duplicate cmd!")
			panic("Error: duplicate cmd!")
		}
		(*cmdMap)[id] = &Msg{
			cmd:  cmd,
			name: msg,
			desc: des,
		}

		lastLine = line
	}
}

// walk dir and sub-dir, get all files with suffix
func WalkDir(dirPth, suffix string) (*list.List, error) {
	files := list.New()
	suffix = strings.ToUpper(suffix)
	err := filepath.Walk(dirPth, func(filename string, fi os.FileInfo, err error) error {
		if fi.IsDir() {
			return nil
		}
		if strings.HasSuffix(strings.ToUpper(fi.Name()), suffix) {
			absName := getAbsName(filename)
			files.PushBack(absName)
		}
		return nil
	})
	return files, err
}

// walk dir without sub-dir, get all files with suffix
func ListDir(dirPth string, suffix string) (*list.List, error) {
	files := list.New()
	dir, err := ioutil.ReadDir(dirPth)
	if err != nil {
		return nil, err
	}
	PthSep := string(os.PathSeparator)
	suffix = strings.ToUpper(suffix) //ignore
	for _, fi := range dir {
		if fi.IsDir() { // ignore sub-dir
			continue
		}
		if strings.HasSuffix(strings.ToUpper(fi.Name()), suffix) { //匹配文件
			files.PushBack(dirPth + PthSep + fi.Name())
		}
	}
	return files, nil
}

func writeCodeFile(keys []int, m *map[int]*Msg, dir string) {
	fileName := dir + "/" + FILE_NAME + ".go"
	fmt.Printf("write map file: %v\n", fileName)

	f, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE, 0666)
	defer f.Close()
	if err != nil {
		fmt.Println("Error: open write file failed!")
		panic(err)
	}

	head := ""
	code := ""
	rcode := ""

	head += "//\n"
	head += "// Copyright (c) 2017 SongCF <songcf_faith@foxmail.com>.\n"
	head += "// file generated by proto4go\n"
	head += "// https://github.com/golang/protobuf\n"
	head += "//\n\n"
	head += "package pb\n\n\n"
	_, e := f.WriteString(head)
	check(e)

	//var Code = map[string]int{
	//	"heart_beat_req":         0,    // 心跳包
	//	"user_login_succeed_ack": 11,   // 登陆成功
	//	"client_error_ack":       13,   // 客户端错误
	//}
	//var RCode = map[int]string{
	//	10:   "user_login_req",         // 登陆
	//	11:   "user_login_succeed_ack", // 登陆成功
	//	1002: "proto_ping_ack",         // ping回复
	//}
	//var Handlers map[int]func(*Session, *packet.Packet) []byte
	code += "var Code = map[string]int{\n"
	rcode += "var RCode = map[int]string{\n"

	tmpStr := ""
	for _, k := range keys {
		tmpStr = fmt.Sprintf("\t%-24s:%-8s,  // %s\n", (*m)[k].name, (*m)[k].cmd, (*m)[k].desc)
		code += tmpStr
		tmpStr = fmt.Sprintf("\t%-8s:%-24s,  // %s\n", (*m)[k].cmd, (*m)[k].name, (*m)[k].desc)
		rcode += tmpStr
	}

	code += "}\n\n"
	rcode += "}\n\n"
	_, e = f.WriteString(code)
	check(e)
	_, e = f.WriteString(rcode)
	check(e)

	cmd := exec.Command("gofmt", "-w", fileName)
	e = cmd.Run()
	check(e)
}

func writeCSV(keys []int, m *map[int]*Msg, dir string) {
	fileName := dir + "/" + FILE_NAME + ".csv"
	fmt.Printf("write csv file: %v\n", fileName)

	f, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE, 0666)
	defer f.Close()
	if err != nil {
		fmt.Println("Error: open write file failed!")
		panic(err)
	}

	_, e := f.WriteString("id,name,desc,\n")
	check(e)
	for _, k := range keys {
		_, e = f.WriteString((*m)[k].cmd + "," + (*m)[k].name + "," + (*m)[k].desc + ",\n")
		check(e)
	}
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func getCurrentDirectory() string {
	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		fmt.Println("Error: get current directory failed!")
		panic(err)
	}
	return strings.Replace(dir, "\\", "/", -1)
}

func getAbsName(file string) string {
	abs, err := filepath.Abs(file)
	check(err)
	return strings.Replace(abs, "\\", "/", -1)
}
