package main

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)


func writeCode(keys []int, m *map[int]*Msg, dir string) {
	fileName := dir + "/" + FILE_NAME + ".go"
	fmt.Printf("write code file: %v\n", fileName)

	f, err := os.OpenFile(fileName, os.O_TRUNC|os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		f.Close()
		fmt.Println("Error: open write file failed!")
		panic(err)
	}

	head := "//\n"
	head += "// Copyright (c) 2017 SongCF <songcf_faith@foxmail.com>.\n"
	head += "// file generated by proto4go\n"
	head += "// https://github.com/songcf/proto4go\n"
	head += "//\n\n"
	head += "package pb\n\n"
	head += "import (\n"
	head += "\t//. \"github.com/songcf/gateway/session\" //your session package\n"
	head += "\t\"github.com/golang/protobuf/proto\"\n"
	head += ")\n\n\n"
	_, e := f.WriteString(head)
	check(e)

	//var Code = map[string]int{
	//	"heart_beat_req":         0,    // 心跳包
	//	"user_login_succeed_ack": 11,   // 登陆成功
	//	"client_error_ack":       13,   // 客户端错误
	//}

	//var RCode = map[int]string{
	//	10:   "user_login_req",         // 登陆
	//	11:   "user_login_succeed_ack", // 登陆成功
	//	1002: "proto_ping_ack",         // ping回复
	//}

	//const (
	//	CmdHeartBeatReq = 0  // 心跳包
	//	CmdUserLoginAck = 1  // 登陆成功
	//)

	//var Handlers = map[int]func(*Session, []byte) (int, []byte) {
	//	0: HeartBeatReq,   // 登陆
	//	1: CmdUserLoginAck, // 登陆成功
	//}

	code := "var Code = map[string]int{\n"
	rcode := "var RCode = map[int]string{\n"
	cst := "const (\n"
	handler := "var Handlers = map[int]func(*Session, []byte) (int, proto.Message) {\n"


	tmpStr := ""
	upStr := ""
	nameWithColon := ""
	for _, k := range keys {
		nameWithColon = "\"" + (*m)[k].name + "\""
		//code
		tmpStr = fmt.Sprintf("\t%-24s:%-8s,  // %s\n", nameWithColon, (*m)[k].cmd, (*m)[k].desc)
		code += tmpStr
		//rcode
		tmpStr = fmt.Sprintf("\t%-8s:%-24s,  // %s\n", (*m)[k].cmd, nameWithColon, (*m)[k].desc)
		rcode += tmpStr
		//const
		upStr = UpFirstChar((*m)[k].name)
		tmpStr = fmt.Sprintf("\tCmd%-21s= %-8s  // %s\n", upStr, (*m)[k].cmd, (*m)[k].desc)
		cst += tmpStr
		//handler
		if strings.HasSuffix((*m)[k].name, "_req") {
			tmpStr = fmt.Sprintf("\t%-9s%-23s  // %s\n", (*m)[k].cmd+":", upStr+",", (*m)[k].desc)
			handler += tmpStr
		}
	}

	code += "}\n\n"
	rcode += "}\n\n"
	cst += ")\n\n"
	handler += "}\n\n"

	// begin write
	_, e = f.WriteString(code)
	check(e)
	_, e = f.WriteString(rcode)
	check(e)
	_, e = f.WriteString(cst)
	check(e)

	f.Close() //close for gofmt
	cmd := exec.Command("gofmt", "-w", fileName)
	e = cmd.Run()
	check(e)


	f, err = os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, 0666)
	if err != nil {
		f.Close()
		fmt.Println("Error: open write file failed!")
		panic(err)
	}
	// if has not define this func, it will fail when exec gofmt
	_, e = f.WriteString("\n\n//define this func by yourself\n" + handler)
	check(e)
	f.Close()
}

func writeCSV(keys []int, m *map[int]*Msg, dir string) {
	fileName := dir + "/" + FILE_NAME + ".csv"
	fmt.Printf("write csv file: %v\n", fileName)

	f, err := os.OpenFile(fileName, os.O_TRUNC|os.O_WRONLY|os.O_CREATE, 0666)
	defer f.Close()
	if err != nil {
		fmt.Println("Error: open write file failed!")
		panic(err)
	}

	_, e := f.WriteString("id,name,desc,\n")
	check(e)
	for _, k := range keys {
		_, e = f.WriteString((*m)[k].cmd + "," + (*m)[k].name + "," + (*m)[k].desc + ",\n")
		check(e)
	}
}
